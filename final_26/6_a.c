/*
How an I2C Slave Identifies Start and Stop Conditions:

    The I2C slave identifies the start and stop conditions by monitoring the SDA (data) and SCL (clock) lines:
        Start Condition: Detected when SDA transitions from high to low while SCL is high. This is generated by the master to initiate communication.
        Stop Condition: Detected when SDA transitions from low to high while SCL is high. This is generated by the master to end communication.
    The slave’s I2C peripheral hardware (e.g., STM32 I2C module) automatically detects these conditions via the SB (Start Bit) flag in the SR1 register for start and the STOPF flag for stop.

Steps to Transfer 1MB of Data Using I2C:

    Initialize I2C Peripheral:
        Enable I2C clock (e.g., RCC_APB1ENR_I2C1EN for I2C1).
        Configure GPIO pins (e.g., PB6 for SCL, PB7 for SDA) with alternate function (AF4 for STM32F4).
        Set I2C clock speed (e.g., 400 kHz) using CCR and TRISE registers.
    Slave Address Configuration:
        Set the slave address in the master’s I2C_OAR1 or target slave address in I2C_DR for transmission.
    Generate Start Condition:
        Write 1 to I2C_CR1_START to initiate a start condition.
        Wait for SB flag in SR1 to be set.
    Send Slave Address:
        Load the 7-bit slave address (shifted left by 1, with R/W bit) into I2C_DR.
        Wait for ADDR flag in SR1 to be set, indicating address acknowledgment.
    Data Transmission:
        For 1MB (1,048,576 bytes), split into manageable chunks (e.g., 256-byte frames due to I2C buffer limits).
        Write each byte to I2C_DR, wait for TXE (Transmit Data Register Empty) flag in SR1.
        Repeat for all chunks, regenerating start conditions as needed (repeated start).
    Handle Acknowledgments:
        Check BTF (Byte Transfer Finished) flag to ensure data is sent.
        Manage NACK by stopping if the slave does not acknowledge.
    Generate Stop Condition:
        Write 1 to I2C_CR1_STOP after the last byte to end transmission.
        Wait for STOPF flag in SR1 to confirm stop condition.
    Repeat for Remaining Data:
        Loop steps 3-7 for subsequent 256-byte chunks until 1MB is transferred.
*/

void I2C_Init(void) {
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
    I2C1->CR1 = I2C_CR1_SWRST; I2C1->CR1 = 0; // Software reset
    I2C1->CR2 |= 36; // 36MHz APB1 clock
    I2C1->CCR = 90; // 400 kHz with 36MHz PCLK
    I2C1->TRISE = 37; // Rise time
    I2C1->CR1 |= I2C_CR1_PE; // Enable peripheral
}

void Transfer_1MB(uint8_t *data, uint32_t size) {
    uint32_t i;
    for (i = 0; i < size; i += 256) {
        I2C1->CR1 |= I2C_CR1_START; while (!(I2C1->SR1 & I2C_SR1_SB));
        I2C1->DR = 0xA0; while (!(I2C1->SR1 & I2C_SR1_ADDR)); (void)I2C1->SR2;
        for (uint32_t j = 0; j < 256 && (i + j) < size; j++) {
            I2C1->DR = data[i + j]; while (!(I2C1->SR1 & I2C_SR1_TXE));
        }
        I2C1->CR1 |= I2C_CR1_STOP; while (I2C1->SR1 & I2C_SR1_STOPF);
    }
}